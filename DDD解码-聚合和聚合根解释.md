# DDD解码 - 有界上下文解释

## SapiensWorks.com作品, LC95自译

[DDD Decoded - The Aggregate and Aggregate Root Explained(Part 1)](http://blog.sapiensworks.com/post/2016/07/14/DDD-Aggregate-Decoded-1)
[DDD Decoded - The Aggregate and Aggregate Root Explained(Part 2)](https://blog.sapiensworks.com/post/2016/07/14/DDD-Aggregate-Decoded-2)
[DDD Decoded - The Aggregate and Aggregate Root Explained(Part 3)](http://blog.sapiensworks.com/post/2016/07/14/DDD-Aggregate-Decoded-3)


## Part1 理论知识

解释这个重要的DDD概念已经用了许多笔墨(真的笔墨或虚拟笔墨)，但正如Vaughn Vernon所说，“聚合是最重要的DDD模式之一，也是最容易被误解的模式之一”。 因为他们很难解释，但是一旦你真正理解了它，一切都变得简单明了。 但是，首先你必须接受DDD与编码无关的事实。 一旦您知道DDD只是一种收集域信息并以技术（开发人员）友好方式组织它的方式，您就可以了解Aggregate及其兄弟概念Aggregate Root。

### 特定于一个业务用例的模型

每次我们改变一些东西的时候，我们必须确保从业务的角度做出了有效的改变。现在，最简单的方法是尽可能地将事物表示成企业所看到的样子。这意味着我们必须确定域使用的**概念**，但更重要的是，我们需要确定概念的相关表示，与使用该概念的业务案例相关。

例如，我可以识别发票的概念，但是我真正需要的是它的表示(模型)，我可以在特定的用例中使用它，比如:创建fa♂票。但是取消发票呢?嗯，它有自己的发票表示。即使涉及相同的概念，每个业务案例也需要它自己的相关模型。我们最终得到的是多个案例一个模型，但是他们是具有相同概念的多个表示形式。是的，我们想这样。相关性是DDD中的关键字。

### 一个CQRS插曲

应用命令查询隔离(CQS)原则，我们问自己:“我是否试图改变这里的东西?”我需要这个模型来更改现有的业务状态吗?如果是，那么我们的模型实际上是一个命令模型(是的，这是来自CQRS的C)，它将包含我们更改业务状态的特定部分所需的所有信息。

对于创建发票案例，我们需要一个仅对该业务案例有意义的发票模型！ 领域专家将告诉您创建发票所需的数据和业务约束，基本上是组成新发票的组件和规则。 我们已经确定了我们的命令模型(Command Model)，它在DDD中称为Aggregate!!

在我们继续之前...

### 一个真实世界的聚合例子

假设你想从宜家买一张桌子。你得到一个桌子吗?不完全是，你在一个盒子里得到了一堆你必须自己组装的组件和指令。假设你从盒子里取出所有的木制部件，螺丝等，然后把它们堆成一堆。你们有桌子吗?不。您有桌子的组件，但是您需要根据一些规则来组装它们，以便最终得到一个桌子。

桌子是一个聚合，它是由(组装)规则“组合”在一起的一组组件，目的是行为像一个单独的东西一样。组件和规则(Vernon称它们为不变量)都构成了聚合。一堆零件组成不了一个表，只是一些组装规则没有任何意义，我们需要所有这些规则来创建我们的表。

聚合是一个模型，它表示我们需要更改的所有相关信息。只有这样，信息才会被组织成组件、其他较小概念的模型以及需要遵守的规则。每次我们想要进行更改时，我们都需要找到聚合, 由它告诉我们相关组件和它们必须遵守的规则。

### 找到聚合

回到我们的桌子示例。首先，我们需要一个旨在做出改变的业务案例。这很重要，因为如果您只需要读取内容，则不需要聚合，而只需要一个简单的读取模型，并且记住**聚合始终是一个命令模型**(用于更改业务状态)。虽然我们并不是真的想要构建一个桌子，但这正是我们需要做的，因此这就是我们的业务案例:组装桌子(注意语义)。

我们希望尽可能精确地识别命令业务案例，这意味着我们希望每个案例都有一个业务状态更改。 很多时候，我们认为这是一个案例，实际上它是一个完整的过程，即一系列案例。 因此，我们需要关注领域专家，他们可以帮助我们确定业务案例的界限。 示例：名为“生成发票”的流程可能涉及“创建发票”和“从发票创建PDF”的情况。 如果我们需要改变不同概念的状态（“Invoice”，“Pdf Invoice”），那么我们可能会处理一个过程。 一个过程也可以跨越多个有界上下文。 但我们只想确定一个业务案例（或者至少我们当时只处理一个案例），即一个相关的业务变化。

然后，我们确定需要更改（创建，更新，删除）的业务概念或域关系, 以及表示它的相关模型。 同样，我们需要一个**特定于该业务案例的模型**。 因此，我们最终得到了许多其他概念（我们也需要他们的模型！）和业务规则。 因此，对于我们的桌子，即已识别的概念，我们需要一个表示，告诉我们构建它所需的重要部分和规则。 在这种情况下，我们很幸运，宜家为我们做了工作，所以我们的模型包括所有木制零件和螺丝，以及装配说明。

### 聚合是业务模型中始终一致的部分

聚合定义了一致性边界，也就是说，它内部的所有内容都需要立即保持一致。这一点很重要，因为它告诉我们，无论需要执行多少实际的更改(状态突变)，我们都必须将它们视为一个提交、一个工作单元，基本上是由需要一起成功的较小的相关更改组成的一个“大”更改。

但我们实际上并没有以一致的方式设计事物;我们将所有这些组件和规则放在一起的事实告诉我们，我们正在处理的是一个组合, 该组合的每一个组件都要始终保持一致性。这样我们就知道我们找到了一个聚合。

有些有趣的情况是，当我们处理域关系时，在某些情况下，我们还需要为它们标识一个聚合。但这是另一篇文章的主题。

### 聚合角色非常具体

这是一件很重要的事情。 我们需要一个模型，因为我们想要进行有效的业务状态更改。 但是，**我们聚合的目的是控制变化**，而不是变化。 是的，我们将数据组织为值对象或实体引用，但这是因为它是实施业务规则的最简单，最易维护的方式。 我们对状态本身并不感兴趣，我们对变化能够确保符合预期更感兴趣，为此我们“借用”域的思维模式，即我们将事物看作是我们业务的一部分。

 聚合实例传达一切对于进行特定的业务状态更改都没问题。 而且，是的，我们需要持久化业务状态的变化。 但这并不意味着聚合本身需要持久化（可能的实现细节）。 请记住，聚合只是一个组织业务规则的构造，它不是一个表示状态的表示。

 如果聚合不是改变其本身，该怎么说?变化会被聚合生成并传递, 这表示一个或多个相关域事件。这些需要记录(持久化)和应用(解释)。当我们应用一个事件时，我们“处理”它的业务含义。这意味着某些值已经改变，或者可以触发业务场景。更多的信息将在以后的文章中介绍。

 你可以说聚合的任务是这样的："基于你给我的输入和我所知道的业务规则，发生了以下业务状态变化：X发生了这些细节。做任何你想做的事情，它不是 我的工作，我这儿已经搞定了"。

### 聚合根的角色

聚合的伴侣是聚合根(AR)我们已经知道应该用AR来操纵聚合中的东西。然而……

### 到处都是历史遗留

最初，DDD混合了大量的OOP的内容。 这就是为什么我们通常有一个以OOP为中心的视角和模式名称。 但今天，DDD是关于识别域模型而不管它将如何实现; 但是它OOP的根（ha！）留下了一些文物，特别是在命名例如值对象时。

聚合根这个名字在OOP方法中是有意义的，其中您有一组对象，并且您只希望一个对象成为“根”，装饰展现整个结构，然而，以更抽象的方式，AR仅仅是强制执行聚合的业务/一致性规则。 所以今天，AR是一个可以由一个对象或仅仅一个函数实现的角色。 如果聚合意味着一组组件和规则，AR就是“监护人”，确保我们处理正确的组件并遵守规则。 在我们的桌子示例中，AR是组装桌子的人。

## Part2 建模示例

第1部分是关于理论的，现在让我们看一个实际的建模示例。

为了简单起见，假设我们正在构建一个银行应用程序，我们已经确定了这个所需的功能：“客户可以将钱从一个帐户转移到另一个帐户”。 让我们看看......我们在这里改变业务\状态吗？ 是的，我们操作然后此操作的结果是客户的帐户将具有不同的值。 因此，我们需要更新两个帐户：account1.Add（value）和account2.Substract（value）并关闭案例。 是吧？

表面上很容易得出结论，我们需要修改两个账户，但是让我们慢慢来。我们知道我们正在进行“变更”操作，即指挥业务案例，因此我们需要识别相关概念，尤其是负责变更的概念。领域专家告诉我们，我们正在处理两个账户之间的转账，或者更准确地说，一个账户贷记另一个账户，另一个账户借记。实际上，我们的商业案例是注册货币转账，我们已经确定了三个概念:转账、借记和贷记，提到转账实际上至少由借记和贷记定义。

但是在我们继续之前，让我们先确定这种变化本身:一种新的转移将成为银行系统状态的一部分，我们将这种变化表示为名为“转账已经注册.”的领域事件。我们总是把变化表达为“自上次变化以来发生的事情”，过去时态很重要:它告诉我们，从业务角度来看，变化已经完成。从技术角度来看，我们需要持久化这种改变，但这是一个实现细节和应用服务的工作。请记住，在现实世界中，变化发生了就会持续下去，但是在虚拟世界中，我们需要一个明确的“保存到数据库”。

建模时，我们的想法是先找出变化，也就是操作的结果，然后确定我们最终需要的所有细节。在这一点上，我们有几个概念，但仅此而已吗？不...领域专家告诉我们，每次转移都应该是可识别的(提示！)通过一个唯一的数字，根据特定的公式生成，我们需要知道创建的日期和时间。借方和贷方必须是不同的账户。

我们现在有足够的信息来确定我们的转账聚合

* 构成:转账数额、贷方、借方、创建日期
* 规则:所有组件都是必需的。信用卡和借记卡针对不同的账户

但这只是顶层视角。我们需要更深入地研究，并确定每个组件的含义，我们希望找到它们的模型。转帐号码是一组数字和字母，必须是唯一的，并根据业务公式生成。基本上是一个遵守某些约束的值。

借款是一个有趣的概念。它基本上是一个需要大于等于的数字，但是它需要与一个帐户相关联或者更准确地说，与一个帐户号相关联。啊哈! 我们发现了另一个概念。帐号也是由业务公式生成的一组数字。因此，借方是一个金额和一个帐号的复合值。

贷方类似于借方，只是名称不同而已，但这就足够作为一个单独的概念来对待了，而这个概念恰好有相同的组成部分。创建日期只是一个简单的datetime值。

现在，从DDD的角度来看，所有这些组件都是值对象，因为每个组件都表示一个具有业务意义的值，并且与转账不同，它们不需要一个显式组件充当标识符。他们的价值就是他们的标识。

在这里，我们看到了如何确定进行更改所需的业务概念、规则和约束，以及如何将它们组织到一组命名模型中。这就是我们的聚合，相关的抽象负责控制域状态的变化。

## Part3 C#代码

编码时间!我敢打赌你等这个一定有一段时间了。是的，一旦我们有了模型，就该编写代码了。让我们首先从值对象开始。

```Csharp
public class TransferNumber{
    public string Value { get; private set; }
    public Guid EntityId { get; private set; }

    public TransferNumber(string value, Guid entityId){
        //根据领域规则做一些验证
        Value = value;
        Entity = entityId;
    }
}
public class AccountNumber:IEquatable<AccountNumber>{
    public string Number { get; private set; }
    public AccountNumber(string number){
        //根据领域规则做一些验证
        Number = number;
    }
    public bool Equals(AccountNumber other) => other != null && Number == other.Number;
}
public class Debit{
    public decimal Value { get; private set; }
    public AccountNumber Account { get; private set; }

    public Debit( decimal value, AccountNumber account){
        Value = value;
        Account = account;
        value.Must( v=> v >= 0 );
        account.MustNotBeNull();
    }
}
public class Credit{
    public decimal Value { get; private set; }
    public AccountNumber Account { get; private set; }

    public Credit( decimal value, AccountNumber account){
        Value = value;
        Account = account;
        value.Must( v=> v >= 0 );
        account.MustNotBeNull();
    }
}
```

代码应该是自解释的，尽管我打赌您对两件事感到疑惑

1. 为什么TransferNumber具有一个Guid？
2. 为什么创建日期不是VO实现

好吧，让我从2号开始。创建日期不需要封装成VO，因为没有实际的业务限制(在这个例子中)。为什么要用另一个类使实现变得复杂呢？
TransferNumber是转让的自然标识，但是，出于技术目的，我更喜欢有一个技术ID，也就是Guid。**我们将在需要指定实体的情况下使用它**，但是我们不需要值对象的全部，例如在消息中。

说到消息，这是我们的领域变化，表示为领域事件

```Csharp
public class TransferedRegistered{
    public Guid EntityId { get; set; }
    public string TransferNumber { get; set; }
    public decimal Amount { get; set; }
    public string DebitAccountNo { get; set; }
    public string CreditAccountNo { get; set; }
    public DateTimeOffset CreatedOn { get; set; } = DateTimeOffset.Now;
}
```

一个漂亮的、扁平的数据结构，包含*有效的*数据。有效，因为它是负责生成它的聚合根(AR)。现在，我将使用一种更“奇异”的方法来实现AR。

```Csharp
public static class Transfer{
    public static TransferedRegistered Create(TransferNumber number, Debit debit, Credit credit){
        number.MustNotBeNull();
        debit.MustNotBeNull();
        credit.MustNotBeNull();

        debit.Account.MustNotBe(credit.Account);

        var ev=new TransferedRegistered();
        ev.EntityId = number.EntityId;
        ev.TransferNumber = number.Value;
        ev.Amount = debit.Value;
        ev.DebitAccountNo = debit.Account.Number;
        ev.CreditAccountNo = credit.Account.Number;
        return ev;
    }
}
```

等等...什么？！静态类？？？静态函数？？？！！！搞什么？！
是的，这叫函数式方法。比起编写DDD模型，我更喜欢混合OOP-FP风格，尤其是AR聚合根。为什么？因为这是最简单的实现。请记住，AR是一个角色，功能是实现。当一个函数足够时，让它成为一个完整的类是没有意义的。

当然，我可能有另一个涉及Transfer的命令案例，但是你看，每个模型只与一个案例相关，我希望我的代码反映这一点。基本上，我希望案例之间有一些界限，所以`Transfer`类是一个概念，每个静态方法都是强制对应特定模型的聚合根。静态的东西意味着他们不应该分享任何状态。他们被分组在一起只是为了方便。

我们的AR确保业务规则得到遵守，然后通过生成和返回域事件来传达更改。

这不是实现我们的模型的唯一方法，但是我喜欢它，因为它使事情变得简单，并且我们的代码是事件来源友好的。在以后的文章中，当我们讨论应用程序服务时，我们将看到服务如何使用AR以及如何处理事件。
