# DDD解码 - 有界上下文解释

## SapiensWorks.com作品, LC95自译

[DDD Decoded - Domain Relationships Explained](http://blog.sapiensworks.com/post/2016/08/24/DDD-Relationships)

在DDD中最难理解的事情之一是两个概念之间的域关系。大多数时候，当人们思考关系时，他们使用程序员的思维方式，他们寻找的是:有`拥有(has-a)`或`是(is-a)`或`父-子(parent-child)`关系，或(更糟的)`一对多(one-to-many)`关系等等。这在编写代码时是有效的，但在进行域建模时是绝对错误的。

我们要寻找的是领域关系，即领域如何从业务角度看待这种关系，或者更准确地说，概念之间的关联/合作程度如何，以及维持这种关系涉及哪些业务规则。通常有两种类型:`强/总是(strong/always)`和`弱/可选(weak/optional)`。

## `strong(always)`领域关系

这个是最简单的：它只是意味着在给定的业务案例中，概念总是需要另一个。 例如：`客户`和`订单`，`作者`和`教程`等。与开发人员的想法相反，它永远不是“客户有订单”，它始终是**关于订单的行为**，可能涉及或不涉及客户。 当客户下订单时，我们需要创建该订单，我们将使用特定的订单聚合。 但订单不是从天而降，客户总是参与其中，因此我们无法在不提及客户的情况下创建新订单。

 但是，如果我们处于“取消订单”的情况下，则不需要关注客户订单关系（前提是有一个Order-OrderStatus）。 因此，我们可以在不涉及/提及客户的情况下取消订单，但正如我所说，现在有一个不同的关系需要处理。

 假设一个订单总是需要有一个状态。把它作为总体的一部分可能很诱人，但是……如果您像业务那样看待它，那么这个值对象成为它的一部分是没有意义的。有意义的是将订单状态视为与订单相关联的一种元数据。

 创建订单时，表示此关系的唯一位置是生成的OrderCreated事件。 这是因为像“待定”这样的状态是隐含的，我们不需要任何特定的输入或业务约束。 但我们仍然需要“宣布”订单具有该状态，因为它是业务状态变化的一部分。

 现在，在取消订单时，我们需要为订单指定不同的状态，但是因为我们可以根据现有的订单状态获得不同的结果，所以我们需要为此确定一个聚合。 此聚合涉及实体订单（通过OrderId）和值对象OrderStatus，并且作为特定于更改订单状态（表示关系本身）的模型，结果更改仍与订单概念相关联。

## `weak(optional)`领域关系

基本上，两个概念可以联系在一起。思考帖子`Post`和类别`Category`。这两个概念都是独立的，但是它们可以一起工作。在业务案例“将帖子分配到类别”中，我们需要根据业务规则创建它们之间的关联。关系聚合将涉及这两个概念，我们得到了一个有趣的情况，因为我们最终有两个实体，但是我们只需要一个作为聚合根。会是哪个？

显然，我们不应该抛硬币。我们需要更好地理解这些概念以及它们关联的目的。事实证明，类别的存在是为了组织帖子，而帖子实际上并不关心类别。这种关系对于类别更重要(相关)，因此我们选择它作为聚合根。这意味着在结果事件中，实体id将是类别的id，而PostId将只是一个字段。

对一种关系而言，即使变化被认为是“属于”特定概念，而聚合永远为了关系而产生的模型。

一个有趣的例子是删除一些东西。如果我软删除一篇帖子，我实际上拥有的是帖子和已删除状态之间的一种新关系，该状态从来不是帖子本身的一部分(作为一个概念)，而是永远与帖子相关联的一些元数据。顺便说一句，状态是一个值对象，即使它的实现只是一个枚举。

另一个例子是“支付发票”。同样的，实体发票(Invoice)和值对象发票状态(InvoiceStatus)之间的关系。状态是发票的**元数据**，我们需要一个关系聚合来更改状态。从领域的角度来看，**与发票实体相关联的一些东西发生了变化**。

## 结论

领域关系最难的部分是正确识别它们；很多时候，尤其是当涉及实体和值对象时，我们可以认为VO是实体聚合的一部分，而事实上它是一种可能需要自己聚合的关系。但是随着更多的练习，发现关系将成为我们的第二天性。