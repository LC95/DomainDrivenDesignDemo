# DDD解码 - 实体和价值对象解释

## SapiensWorks.com作品, LC95自译

[DDD Decoded - Entities and Value Objects Explained](http://blog.sapiensworks.com/post/2016/07/29/DDD-Entities-Value-Objects-Explained)

DDD思维模式的主要内容之一是将**业务概念**划分为:*实体*和*值对象*。注意，我说的是概念而不是对象。不同之处在于，对象*可能是*概念模型的实现。这不是关于我们如何编写代码，而是关于我们如何以一种对开发人员友好的方式“标记”一个业务方面。

## 为什么需要这些策略模式

DDD的一个实际优势是，它告诉我们如何以一种更容易实现的方式组织域信息。一旦我们知道我们在处理一个实体或一个值对象，我们就会得到一些关于如何继续建模或实现的提示。

## 其实例拥有唯一标识是实体的概念

实际上，这有点多:是的，它们都有一个不可变的只读方面或细节(不管你怎么称呼它)作为标识符，但是实体的问题是，我们可以改变与其相关的一切(除了它的id )，它仍然是同一个实例。听起来有点抽象和枯燥，但事情通常很简单。很容易识别一个实体的概念:领域专家将把它称为一个单一的、可识别的项目。*客户、发票、订单、物品、帖子*等是作为实体的常见概念的例子。只要企业关心**跟踪**这个概念的每个实例，我们就在处理实体。

在许多情况下，您可以直接得到提示:领域专家会提到一个惟一的数字或惟一的id或序列号等作为概念定义的一部分。更重要的是，当我们为更改该概念的实例的业务用例确定模型时，我们每次都会看到所提到的识别细节。

## 实体告诉我们什么

最重要的提示是，一个实体指定了一个“更大”的概念，因此我们处理的是一个聚合，我们需要“挖”得更深，以便找到它的组成和业务规则。另一件事是一个实体不能成为另一个实体的聚合的一部分。但是我们可以有引用(不是最好的词)，也就是说，聚合可以“指向”另一个实体。也许更好的说法是，当有两个实体之间的域关系，一个“需要”另一个，我们通过引用另一个实体的id来表达此关系。

例如，订单总是由客户下的，因此订单实体与客户概念有关系，在某种意义上，我们需要将客户表示为订单创建聚合的一部分。但是由于Customer是一个实体，因此只有它的id是订单聚合的一部分。

## 值对象是具有业务意义的简单值或组合值

提醒一下，早期的DDD混合了OOP，值对象(VO)的更好名称应该是一个值概念。但名称是根深蒂固的，所以我们一直说Value Objects，即使它的实现不是对象。VOs通常不像实体那样受到同等的尊重，但是它们同样重要。识别VO并不难，它是一个没有明确身份细节的概念。实际上，我们可以说VO的恒等式是由VO所有的值来表示的。改变一些东西，它就变成了另一个值。

VO不仅具有值，而且还包含值需要遵守的业务约束。基本上，VO是一个“小”概念，是(大概念)实体的一部分。大多数VO都足够小，1-2个值，但是我们可以用更大的VO结合其他VO。

让我们举个例子:价格是一个概念，它由两个值表示:数量和货币(本身为VO)。它没有明确的标识，最重要的是，业务不会区分这个5美元和那个5美元。

另一个例子是订单的订购产品，订单实体的详情。 不，我没有看到任何关于'OrderLines'的业务，但他们谈论订单的`商品(OrderItem)`。 值对象`OrderItem`由三件事物组成：产品，数量和价格。 作为一个概念，Product是一个实体，VO不能包含实体，因此我们所拥有的是`ProductId`（或SKU），它本身就是一个VO。 并且看起来`OrderItem`可能有一个识别细节，产品，用于从订单中识别特定项目并使项目看起来像一个实体，但重要的是`OrderItem`是订单的一个组成部分，一个次要概念， 不在订单外直接使用。 业务不能仅通过其`Id`来识别`OrderItem`，它总是需要`Order`作为该“id”的上下文。 这就是使其成为VO的原因，真正的实体不需要另一个实体成为可识别的实体。

有时很难确定一个概念的本质，它可能看起来像一个实体，但是如果它表示一个次要的概念，而这个概念只在作为另一个实体的一部分才有意义，那么我们处理的就是VO。

## VO告诉我们什么

* 业务约束——VO传递业务语义，通常这意味着这些值需要遵守业务规则。一个VO总是有效的。
* 不变性-由于它的性质，一个VO从不改变。它不能改变，否则它会变成另一个值。所以，设置它的值一次，就是这样。
* 通常是聚合的一个组成部分——业务功能处理实体，而不是独立的VO实例。理想情况下，聚合的所有组件都是VO。
* 语义>结构 价格有数量和货币。折扣也有数量和货币。它们是同一个概念吗?并不是，企业关心这个。即使两个VO具有相同的结构和业务约束，它们也不相同，应该作为不同的东西来实现。DRY在这里不适用，永远不要重复使用VO

这些提示使我们很容易实现VO，我个人倾向于在对象的构造函数和getter中执行业务规则。VO可以有方法，但是这些方法不应该改变VO，你只能创建新的VO。

在某些情况下，VO实现可能只是一个简单的枚举(想想`OrderStatus`: Pending - In - progress - Completed)，没有必要把我们的生活复杂化。

## 当涉及到CQRS

尽管概念的本质是相同的，但无论它是命令还是查询，这些模式只对命令模型有意义。查询模型只是一些(只读)数据，可以跨越多个概念。虽然我们可以使用一些VO进行查询，但这主要是一种DRY的便利。

## 结论

只要我们正确地识别事物，就可以使用这些策略模式来组织业务概念。我看到的最常见的错误是开发人员指向一个充满基本类型的数据结构并说:“我有这个实体”。不要将**概念的性质**与**其命令模型的可能实现**混淆。