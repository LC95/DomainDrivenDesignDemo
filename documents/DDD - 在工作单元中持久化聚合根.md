# DDD - 在工作单元中持久化聚合根

## SapiensWorks.com作品, LC95自译

[DDD - Persisting Aggregate Roots In A Unit Of Work](http://blog.sapiensworks.com/post/2013/05/01/DDD-Persisting-Aggregate-Roots-In-A-Unit-Of-Work.aspx)

在DDD中，有时必须在事务(工作单元)中包含两个或多个聚合根(AR)。它们可以被修改，这没问题，但是如何持久化呢?!每个AR都有一个存储库，每个AR实际上定义了自己事务的边界。我们如何在一个工作单元中保存所有的聚合根

有两个例子:

您正在使用一个事务存储，如RDBMS。 在这种情况下，事情非常简单：将db事务封装在UnitOfWork中，并查看所有涉及的存储库是否通过其构造函数接收db事务。 如果您使用ORM，这会变得更加简单。

您没有使用事务存储，或涉及多个数据存储。 即使使用RDBMS，只要涉及2个数据库，无法使用事务。该怎么办？

好消息是你用的是DDD，让我们想一下。DDD的主要优势是什么?您正在代码中建模业务概念和业务流程。这意味着业务工作流可以告诉我们如何实现该事务。

我们来考虑这样一个情况：我们有一个库存和一个订单。 这些是我们的AR，我们希望简单地将货物从库存移动到订单，在代码中，这类似于从库存中减去数量并将相同数量添加到订单。 典型的交易。

但是，让我们看看它将如何在现实世界中完成。 假设我们有2个房间：库存和订单。 首先，您不会在没有业务原因的情况下从库存中添加/取货。 当供应商交付货物时库存增加，当货物转移到订单（或其他商业活动）时库存减少。 订单也是一样，商品不是从天上出现, 它们来自库存。 这些方面对于理解我们应该如何对交易建模非常重要。

货物到达订单房间，因此交易成功。 但如果出现问题怎么办？ 如果库存没有足够的货物，则不会向订单发送任何内容，并且当场拒绝交易。 但是，如果订单拒绝货物（因为它已经有货物）怎么办？ 在这种情况下，自然的方式是将货物退回库存。 退回后，库存将具有与以前相同的库存，而订单无论如何都不会更改。 这是现实生活中的回滚。

知道了这些，在代码中实现它们就变得很简单了。但这里有一个小问题:它需要消息驱动的方法，并且对最终一致性的概念非常熟悉。

我们有一个工作单元中使用的库存和订单聚合根。与其这样做:开始事务->修改库存->修改订单->保存库存->保存订单->提交，还不如在我们将在实际业务中使用工作流。

你不会对库存说:“从库存中减去3”，你会说:“为订单分配数量”。如果可以，库存将修改其状态，然后生成一个事件:商品分配完成。该事件的一个处理程序将更新订单:"收到库存的商品"。如果一切正常，订单就会改变它的状态。如果不是，事件处理程序将发出"返回库存"命令，这基本上是对库存的回滚。

第一种选择是传统的选择，最简单的理解和使用方法，但是：

* 它需要最多一个事务存储。
* 它要求在同一时间进行修改，例如，您不能跨越2个Web请求跨越事务。
* 你不能使用多个存储
* 可扩展性差。
* 它不利用DDD。

第二种选择显然有点奇怪(如果您不习惯消息驱动的应用程序)，但是:

* 它利用了DDD，因此它是由业务流程建模的，所以它很自然。
* 适用于分布式环境。
* 它与存储无关。
* 它可以很容易地缩放。
* 它需要优秀的开发人员和对域的正确理解，并对消息驱动的架构感到满意。

我支持第二种方法，但第一种方法在某些情况下可能是实用的解决方案。花点时间思考并选择更适合你的应用的选项是很重要的。记住，魔鬼隐藏在细节中，所以不要匆忙做决定。