# DDD解码 - 使用CQS建模

## SapiensWorks.com作品, LC95自译

[DDD Decoded - Modelling with CQS](https://blog.sapiensworks.com/post/2016/08/22/DDD-Cqs-Cqrs)

虽然CQS/CQRS比DDD要新一点, 但是他们还是能够很好地一起工作, 简单地使用它就行. 我不是说CQRS是架构视角的, 它是建模视角的.

简单地说，当我们确定一个业务用例时，我们会问自己:“这个用例是否**有意**改变业务状态?”我们讨论的不是特定的状态(对象、表等)，而是整个业务状态(请记住，在现实世界中，任何更改都是隐式持久的)。如果是，那么它是一个命令用例，否则它是一个查询用例(这是工作中的CQS)。

处于查询用例中意味着您知道您不会更改任何东西，并且模型将是只读的(这是CQRS，因为我们最终会得到专门的读模型)。

例如，假设我们有创建发票业务案例。 显然，企业希望保留新的发票，因此我们的业务案例将会改变业务状态。 我们刚刚也确定了一个概念，即我们需要找到相关表示的发票。但是因为我们正在创建发票，我们需要一个**命令表示**，即聚合。

这很好，但是除了发票还有更多的概念。我们需要从订单中得到产品和价格，我们还需要计算税金等等。每个概念都有一个模型，但是因为我们不需要改变这些概念所负责的业务状态，我们会用**读取模型**表示。因此，订单模型将是某种**只读结构**，其中包含发票所需的所有数据。我们总是试图为特定的情况确定最相关的模型，而不是一个适用于所有情况的通用模型。

作为一个通用的“规则”，将业务用例看作是一个有界的上下文, 它有一个模型，只有在它里面才有意义。概念涉及到许多业务案例，但是我们只使用它们最相关的模型，并且基于我们需要的操作(写或读)，我们最终为*每个*概念提供一个命令模型或查询模型。

因此，在命令用例中，我们可以找到不同概念的命令和查询模型，而在查询用例中，我们只处理读(查询)模型。在建模时尽早应用CQS可以帮助我们提前知道我们要寻找的模型类型，这可以让我们更加清晰和提高生产力。